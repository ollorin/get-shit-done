---
phase: 02-auto-mode-refinement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ~/.claude/get-shit-done/bin/gsd-circuit-breaker.js
  - ~/.claude/get-shit-done/bin/gsd-tools.js
  - .planning/circuit-breaker/timeout-log.jsonl
  - .planning/circuit-breaker/thresholds.json
autonomous: true

must_haves:
  truths:
    - "Iteration caps (15-20 steps) are primary safety net"
    - "Time limits are configurable per model (20m Haiku, 40m Sonnet, 60m Opus)"
    - "Circuit breaker trips attempt salvage before escalation"
    - "Timeout events are logged for threshold tuning"
    - "Adaptive thresholds adjust based on task complexity"
  artifacts:
    - path: "~/.claude/get-shit-done/bin/gsd-circuit-breaker.js"
      provides: "Circuit breaker module wrapping opossum"
      exports: ["createTaskBreaker", "executeWithIterationCap", "getAdaptiveThresholds"]
    - path: ".planning/circuit-breaker/thresholds.json"
      provides: "Adaptive threshold configuration and learned adjustments"
    - path: ".planning/circuit-breaker/timeout-log.jsonl"
      provides: "Timeout event log for tuning"
  key_links:
    - from: "gsd-circuit-breaker.js"
      to: "opossum"
      via: "require('opossum')"
      pattern: "require.*opossum"
    - from: "gsd-circuit-breaker.js"
      to: "timeout-log.jsonl"
      via: "logTimeout append"
      pattern: "appendFileSync.*timeout-log"
---

<objective>
Implement circuit breaker infrastructure using opossum library with iteration caps, configurable timeouts, and adaptive thresholds based on task complexity and learning.

Purpose: Prevent runaway execution through hard iteration caps and model-specific timeouts, with recovery mechanisms that attempt to salvage work before escalating (AUTO-11).

Output: gsd-circuit-breaker.js module with opossum wrapper, threshold management, and timeout logging.
</objective>

<execution_context>
@/Users/ollorin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ollorin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-auto-mode-refinement/02-RESEARCH.md
@.planning/phases/01-auto-mode-foundation/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install opossum and create circuit breaker module</name>
  <files>~/.claude/get-shit-done/bin/gsd-circuit-breaker.js</files>
  <action>
1. **Install opossum** in ~/.claude/get-shit-done/:
   ```bash
   cd ~/.claude/get-shit-done && npm install opossum
   ```
   (If package.json doesn't exist, create minimal one first)

2. **Create gsd-circuit-breaker.js** with these functions per user decisions:

   **Base thresholds** (user decision: configurable per model):
   ```javascript
   const BASE_THRESHOLDS = {
     haiku: { timeout_ms: 20 * 60 * 1000, iterations: 15 },  // 20min
     sonnet: { timeout_ms: 40 * 60 * 1000, iterations: 20 }, // 40min
     opus: { timeout_ms: 60 * 60 * 1000, iterations: 25 }    // 60min
   };
   ```

   **getAdaptiveThresholds(task, model)** - Returns thresholds adjusted by:
   - Task complexity (complex tasks get +50% limits per user decision)
   - Learned multipliers from thresholds.json (if pattern matches)
   - Complexity estimation uses keywords: database, migration, architecture, integration, security = high complexity

   **createTaskBreaker(taskFn, task, model)** - Factory for opossum circuit breaker:
   - Options: timeout from getAdaptiveThresholds, errorThresholdPercentage: 50, resetTimeout: 30000
   - Event handlers: timeout → logTimeout(), failure → console.error, success → console.log
   - Fallback: salvageOrEscalate(task, model, err) - returns placeholder (actual escalation in Plan 03)

   **executeWithIterationCap(taskStepFn, task, model, maxIterations)** - Primary safety:
   - Loop with iteration counter
   - Check result.complete after each step
   - Log warning at 80% of cap
   - Throw Error if cap exceeded: "Task exceeded iteration cap (N)"
   - User decision: iteration cap has HIGHER priority than time limits

   **logTimeout(entry)** - Append to .planning/circuit-breaker/timeout-log.jsonl:
   - Fields: timestamp, task_id, model, timeout_ms, iterations, reason

   **loadThresholds() / saveThresholds(thresholds)** - CRUD for thresholds.json:
   - Load learned multipliers for known patterns
   - Save updated thresholds after learning

NOTE: Use require('opossum') for circuit breaker. Iteration cap is separate logic (manual loop), not opossum.
  </action>
  <verify>
    - opossum installed: ls ~/.claude/get-shit-done/node_modules/opossum
    - File exists: ~/.claude/get-shit-done/bin/gsd-circuit-breaker.js
    - Exports: createTaskBreaker, executeWithIterationCap, getAdaptiveThresholds, loadThresholds
  </verify>
  <done>
    Circuit breaker module created with opossum integration, iteration caps, and adaptive threshold logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Add circuit breaker CLI commands to gsd-tools.js</name>
  <files>~/.claude/get-shit-done/bin/gsd-tools.js</files>
  <action>
Add circuit-breaker subcommands to gsd-tools.js by requiring gsd-circuit-breaker.js:

1. **circuit-breaker thresholds** - Get thresholds for model
   - Args: --model (haiku|sonnet|opus), --task (optional task description for adaptive)
   - Returns: { timeout_ms, iterations, complexity_multiplier, learned_multiplier }

2. **circuit-breaker update-threshold** - Update learned multiplier for pattern
   - Args: --pattern, --multiplier (e.g., 1.5 for +50%)
   - Saves to thresholds.json

3. **circuit-breaker log** - Read timeout log
   - Args: --model (optional filter), --limit (default 20)
   - Returns: array of timeout entries from JSONL

4. **circuit-breaker stats** - Timeout statistics
   - Calculates: total timeouts, by-model breakdown, average time-to-timeout
   - Returns JSON with stats

Add require for gsd-circuit-breaker.js at top of gsd-tools.js:
```javascript
const circuitBreaker = require('./gsd-circuit-breaker');
```

Pattern follows existing subcommand structure (routing, quota, validation).
  </action>
  <verify>
    - `node ~/.claude/get-shit-done/bin/gsd-tools.js circuit-breaker thresholds --model haiku` returns { timeout_ms: 1200000, iterations: 15, ... }
    - `node ~/.claude/get-shit-done/bin/gsd-tools.js circuit-breaker thresholds --model sonnet --task "database migration"` shows complexity_multiplier: 1.5
  </verify>
  <done>
    CLI commands for circuit breaker operations integrated into gsd-tools.js
  </done>
</task>

<task type="auto">
  <name>Task 3: Initialize circuit breaker state files and test</name>
  <files>
    .planning/circuit-breaker/timeout-log.jsonl
    .planning/circuit-breaker/thresholds.json
  </files>
  <action>
1. Create .planning/circuit-breaker/ directory if not exists

2. Initialize thresholds.json with default structure:
   ```json
   {
     "version": "1.0",
     "created": "TIMESTAMP",
     "base": {
       "haiku": { "timeout_ms": 1200000, "iterations": 15 },
       "sonnet": { "timeout_ms": 2400000, "iterations": 20 },
       "opus": { "timeout_ms": 3600000, "iterations": 25 }
     },
     "learned": {},
     "complexity_keywords": ["database", "migration", "architecture", "integration", "security", "schema", "payment", "transaction"]
   }
   ```

3. Initialize timeout-log.jsonl with header:
   ```json
   {"_comment":"GSD circuit breaker timeout log","created":"TIMESTAMP"}
   ```

4. Test circuit breaker commands:
   - `circuit-breaker thresholds --model haiku` → base thresholds
   - `circuit-breaker thresholds --model sonnet --task "implement database migration"` → 1.5x multiplier
   - `circuit-breaker update-threshold --pattern "migration" --multiplier 1.8` → saves to learned
   - `circuit-breaker thresholds --model sonnet --task "migration task"` → shows learned multiplier

5. Verify timeout logging works by calling logTimeout with test entry
  </action>
  <verify>
    - Directory exists: .planning/circuit-breaker/
    - File exists: .planning/circuit-breaker/thresholds.json with valid JSON
    - File exists: .planning/circuit-breaker/timeout-log.jsonl
    - circuit-breaker commands work correctly
  </verify>
  <done>
    Circuit breaker state files initialized, adaptive thresholds working, CLI commands tested
  </done>
</task>

</tasks>

<verification>
1. opossum library installed and importable
2. gsd-circuit-breaker.js exports all required functions
3. Base thresholds match user specification (20m/40m/60m)
4. Complexity keywords trigger 1.5x multiplier
5. Learned multipliers persist in thresholds.json
6. Timeout events logged to JSONL
</verification>

<success_criteria>
- createTaskBreaker() wraps task function in opossum circuit breaker with correct timeout
- executeWithIterationCap() enforces iteration limit with 80% warning
- getAdaptiveThresholds() applies complexity and learned multipliers
- Circuit breaker CLI commands work for threshold management and logging
</success_criteria>

<output>
After completion, create `.planning/phases/02-auto-mode-refinement/02-02-SUMMARY.md`
</output>
