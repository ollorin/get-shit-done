# Phase 10.1: Multi-Instance MCP Safety - Context

**Gathered:** 2026-02-17
**Status:** Ready for planning

<domain>
## Phase Boundary

Enable multiple Claude Code instances to run simultaneously on the same machine, sharing a single global Telegram MCP server without conflicts, answer confusion, or race conditions. Each instance maintains isolated question queues with proper file locking, session tracking, and answer routing.

</domain>

<decisions>
## Implementation Decisions

### Architecture Model
- **Single global MCP server** shared across multiple Claude Code instances (not per-instance servers)
- Connection architecture: Claude's discretion (auto-start on first connection vs long-running daemon)
- Multi-client server pattern with session isolation per Claude Code instance

### Storage Strategy
- **Per-session JSONL files** in `.planning/telegram-sessions/<session-id>.jsonl`
- Session ID format: Claude's discretion (UUID vs timestamp-based)
- **Pure JSONL format** - one line per entry, no header/footer structure
- Session metadata stored **as first line or special type** in JSONL (not separate file)

**Metadata to store:**
- Process info: PID, working directory
- Session timestamps: start time, last activity (heartbeat)
- User-friendly label: optional contextual name (feature name, blocked phase name)
- Tasks: all tasks generated from the session
- Additional debug info: Claude identifies other useful tracking data

**Answered questions:** Keep in session file with 'answered' flag (complete history in one file, no separate archive for answered)

**Session discovery:** Claude decides strategy (directory scan vs index file) for MCP server startup

**Error handling:** Self-healing - recreate corrupted session files and log warning, don't fail operation

### Locking Mechanism
- Locking library: Claude's discretion (proper-lockfile vs fs-ext flock vs built-in)
- Lock granularity: Claude decides based on architecture (per-file vs per-operation)
- Access coordination: Claude identifies all read/write actors (Claude writes questions, MCP reads; MCP/bot writes answers, Claude reads)
- **Retry with exponential backoff** on lock acquisition failures (3-5 retries, 100ms/200ms/400ms delays)

### Session Lifecycle
- Termination detection: **Both PID check + heartbeat** (PID for immediate detection, heartbeat for zombie processes)
- Cleanup timing: **On MCP server startup + on new session creation** (opportunistic cleanup)
- **24-hour TTL** for abandoned session detection (conservative approach)
- Close strategy: **Both explicit close signal + automatic fallback** (explicit preferred, automatic for crashes)

**Stale session cleanup:**
- Move entire session file to `.planning/telegram-sessions/archive/YYYY-MM-DD/<session-id>.jsonl`
- Archive contains answered + unanswered questions (sessions can't be resumed)
- Date-based folder structure (YYYY-MM-DD) for organization
- `.gitignore` the archive folder

**Comprehensive logging in session JSONL:**
- All message exchanges (questions sent, answers received) with timestamps
- System events (session start/end, heartbeats, cleanup triggers)
- Error events (delivery failures, timeouts, lock conflicts)
- Additional debug info: Claude decides what else is useful for troubleshooting multi-instance coordination

### Answer Routing
- Question identification in Telegram: **Show session label/project name** (e.g., "[feature-name] Question: ...")
- Label is **optional/contextual** - meaningful when present (feature name, blocked phase name), omitted otherwise
  - Note: Multiple sessions work on same project/milestone, different features/phases
  - Labels only useful when there's distinguishing context (not always the case)
- Routing strategy: Claude's discretion (session_id in question object vs routing table vs file scan)

**Button-based UI flow:**
1. User clicks button in bot
2. Bot shows list of pending questions as buttons
3. User selects a question (clicks button)
4. Bot shows full question text and prompts for reply
5. User sends reply
6. Bot writes answer to correct session file
7. Claude gets notification and reads answer
8. Claude marks question as answered
9. Question disappears from bot list

**Button content:** Claude decides what to show (session label, question preview, timestamp) to help user identify questions

### Claude's Discretion
- Connection architecture (auto-start vs daemon)
- Session ID format (UUID vs timestamp)
- Session discovery strategy on startup
- Locking library and granularity
- Read/write actor identification and coordination
- Routing strategy (session_id vs routing table vs scan)
- Button content for question list
- Additional metadata and debug info to track

</decisions>

<specifics>
## Specific Ideas

- **No session resumption:** Sessions that terminate cannot be resumed, so archive entire file
- **Haiku for debugging:** No need for special CLI tools - Haiku subagent can read files if needed
- **Comprehensive audit trail:** Record everything in session file for debugging multi-instance issues
- **Session labels optional:** Not all sessions have meaningful labels (same project, different phases)
- **Self-healing storage:** Don't fail operations on corrupted files, recreate and continue

</specifics>

<deferred>
## Deferred Ideas

None - discussion stayed within phase scope

</deferred>

---

*Phase: 10.1-multi-instance-mcp-safety*
*Context gathered: 2026-02-17*
